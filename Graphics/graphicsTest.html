 <html>
	<head>           
			<script id="vertex" type="x-shader">
				attribute vec2 aVertexPosition;
				void main() 
				{
					gl_Position = vec4(aVertexPosition, 0.0, 1.0);
				}
			</script>  

			<script id="fragment" type="x-shader">
				    #ifdef GL_ES
					precision highp float;
					#endif
					uniform vec4 uColor;
					                       
					void main() 
					{
						gl_FragColor = uColor;
					}
			</script>        
			<script type="text/javascript">

					var gl;
					var aspect;
					//var vbuffer;
					var program;

					function init()
					{
						canvas = document.getElementById("mycanvas");

						/*========================= CAPTURE MOUSE EVENTS ========================= */
						var drag=false;
						var old_x, old_y;
						var mouseDownEvent;
						var mouseUpEvent;
						var mouseDown=function(e) 
						{
							mouseUpEvent = false;
							mouseDownEvent = true;
							drag=true;
							old_x=e.pageX, old_y=e.pageY;
							e.preventDefault();
							return false;
						};

						var mouseUp=function(e)
						{
							mouseUpEvent = true;
							mouseDownEvent = false;
							drag=false;
						};

						var mouseMove=function(e) 
						{
							if (!drag) return false;
							var dX=e.pageX-old_x,
							    dY=e.pageY-old_y;
							// THETA+=dX*2*Math.PI/canvas.width;
							// PHI+=dY*2*Math.PI/canvas.height;
							old_x=e.pageX, old_y=e.pageY;
							e.preventDefault();
						};

						canvas.addEventListener("mousedown", mouseDown, false);
						canvas.addEventListener("mouseup", mouseUp, false);
						canvas.addEventListener("mouseout", mouseUp, false);
						canvas.addEventListener("mousemove", mouseMove, false);

						/*========================= CANVAS AND SHADERS ========================= */
					    gl = canvas.getContext("experimental-webgl"); //
						gl.viewport(0, 0, canvas.width, canvas.height);
						gl.clearColor(0, 0.5, 0, 1); //drawing viewfinder color
						gl.clear(gl.COLOR_BUFFER_BIT);
						
			    		var v = document.getElementById("vertex").firstChild.nodeValue;
						var f = document.getElementById("fragment").firstChild.nodeValue;
						 
						var vs = gl.createShader(gl.VERTEX_SHADER);
						gl.shaderSource(vs, v);
						gl.compileShader(vs);
						
						var fs = gl.createShader(gl.FRAGMENT_SHADER);
						gl.shaderSource(fs, f);
						gl.compileShader(fs);
						
						program = gl.createProgram();
						gl.attachShader(program, vs);
						gl.attachShader(program, fs);
						gl.linkProgram(program);

						if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
							console.log(gl.getShaderInfoLog(vs));

						if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
							console.log(gl.getShaderInfoLog(fs));

						if (!gl.getProgramParameter(program, gl.LINK_STATUS))
							console.log(gl.getProgramInfoLog(program));

						//set up arrays
						aspect = canvas.width / canvas.height;

						maxUnits = 100 //temp
						var toDraw = new DrawGroup(maxUnits, [0.0, 1.0, 0.0, 1.0]); 
						var selected = new DrawGroup(maxUnits, [0.0, 0.3, 0.0, 1.0]); //FIXME: can't seem to color this group properly and rects in this group don't move
						var myGroups = [toDraw, selected];

						// r1 = new Rectangle([0, 0], 0.125, 0.125);
						// r2 = new Rectangle([.5, .5], 0.125, 0.125);
						// r3 = new Rectangle([0, 0.25], 0.25, 0.25);
						// r4 = new Rectangle([0.25, 0], 0.25, 0.25);

						// t1 = new Triangle([0, 0], 0.125, 0.125);
						// t2 = new Triangle([.5, .5], 0.125, 0.125);

						// c1 = new Circle([0, 0], 0.125);
						// c2 = new Circle([0.5, 0.5], 0.125);

						// toDraw.group.push(c1);
						// toDraw.group.push(c2);

						//Unit(center, shape, owner)
						u1 = new Unit([0, 0], "rectangle", true);
						u2 = new Unit([0.5, 0.5], "triangle", false);

						toDraw.add(u1);
						toDraw.add(u2);

						function update()
						{
							var i; var j; 
							// var combinedGroup = new DrawGroup(maxUnits, [0.0, 1.0, 0.0, 1.0])
							// for(i=0; i < myGroups.length; i++)
							// {
							// 	for(j=0; j < myGroups.length; j++)
							// 	{
							// 		combinedGroup.group.push(myGroups[i].group[j]);
							// 	}
							// }

							/*========================== USER EVENTS ==================================*/
							if (mouseDownEvent)
							{
								mouseDownEvent = false;	
								for(i=0; i < toDraw.group.length; i++)
								{
									toDraw.group[i].mouseDown(old_x, old_y);
								}
							}
							else if (mouseUpEvent)
							{
								mouseUpEvent = false;
							}

							/*====================== COLLISON CHECKS ================================*/
							toDraw.checkForCollisions(); 

							/*============================ CHECK ATTACKS ==========================*/
							for(i=0; i < toDraw.group.length; i++)
							{
								for(j=0; j < toDraw.group.length; j++)
								{
									if(i != j)
									{	
										if (toDraw.group[i].inRange(toDraw.group[j]))
										{
											//TODO: start attacking animation
											toDraw.group[i].dealDamage(toDraw.group[j]);
										}
										else
										{
											//TODO: end attacking animation
										}
									}
								}
							}


							/*========================== UPDATES ==================================*/
							for(i=0; i < toDraw.group.length; i++)
							{
								toDraw.group[i].update()
							}
						}

						function drawLoop()
						{
							toDraw.clear();
							gl.clear(gl.COLOR_BUFFER_BIT);
							var i; var j;
							for(i=0; i < myGroups.length; i++)
							{
								for(j=0; j < myGroups[i].group.length; j++)
								{
									myGroups[i].group[j].draw(myGroups[i]);
								}
								myGroups[i].render();
							}
						}

						setInterval(update, 1);

						setInterval(drawLoop, 16);
					}

					function DrawGroup(maxUnits, color=[])
					{
						this.v = new Float32Array(maxUnits*12);
						var i;
						for(i=0; i < this.v.length; i++)
						{
							this.v[i] = 0;
						}
						this.index = 0;
						this.group = [];
						this.color = color;
					}

					DrawGroup.prototype.add = function(toAdd)
					{
						toAdd.dGroup = this;
						toAdd.index = this.group.length;
						this.group.push(toAdd); 
					}

					DrawGroup.prototype.remove = function(toRemove)
					{
						toRemove.dGroup = null;
						this.group.splice(toRemove.index, toRemove.index+1);
					}

					DrawGroup.prototype.render = function()
					{
						itemSize = 2;
						numItems = this.v.length / itemSize;

						//gl
						gl.useProgram(program);
     
						program.uColor = gl.getUniformLocation(program, "uColor"); //get color from program
						gl.uniform4fv(program.uColor, this.color); //set color

						program.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"); //get vertex position from program
						gl.enableVertexAttribArray(program.aVertexPosition);
						gl.vertexAttribPointer(program.aVertexPosition, itemSize, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.TRIANGLES, 0, numItems)
					}

					DrawGroup.prototype.clear = function()
					{
						var i;
						for (i=0; i < this.v.length; i++)
						{
							if(this.v[i] != 0)
							{
								this.v[i] = 0;
							}
						}
						this.index = 0;
					}

					DrawGroup.prototype.checkForCollisions = function()
					{
						var i; var j;
						for (i=0; i < this.group.length; i++) //pairwise comparison
						{
							for(j=0; j < this.group.length; j++)
							{
								if(j != i)
								{
									var iTopRight = [this.group[i].right, this.group[i].top]; 
									var iTopLeft = [this.group[i].left, this.group[i].top];
									var iBottomRight = [this.group[i].right, this.group[i].bottom];
									var iBottomLeft = [this.group[i].left, this.group[i].bottom];
									
									if(this.group[j].in(iTopRight) || this.group[j].in(iTopLeft) ||
										this.group[j].in(iBottomRight) || this.group[j].in(iBottomLeft))
									{
										this.group[i].moving = false;
										var newPos;
										var distanceToMove = 0.01; //TODO: Tune me
										xvector = this.group[i].center[0] - this.group[j].center[0];
										yvector = this.group[i].center[1] - this.group[j].center[1];
										mag = Math.sqrt(xvector * xvector + yvector * yvector);
										xunit = 1 * xvector / mag;
										yunit = 1 * yvector / mag;
										newPos = [this.group[i].center[0] + xunit * distanceToMove, this.group[i].center[1] + yunit * distanceToMove]
										this.group[i].setPos(newPos);

										//TODO: resume moving once obstacle is moved. pathfinding related
									}
								}
							}
						}
					}
					
					/*========================================================  UNIT CLASS =======================================================*/

					function Unit(center, shape, owner)
					{
						this.owner = owner;
						this.shape = shape;
						if(this.shape == "rectangle")
						{
							this.health = 30; 
							this.range = 1; //TODO: tune me
							this.speed = 0.05;
							this.attack = 1; // TODO: tune me
							this.gObject = new Rectangle(center, 0.125, 0.125);
						}
						else if(this.shape == "triangle")
						{
							this.health = 20; 
							this.range = 1; //TODO: tune me
							this.speed = 0.05;
							this.attack = 1; // TODO: tune me
							this.gObject = new Triangle(center, 0.125, 0.125);
						}
						else if(this.shape == "circle")
						{
							this.health = 10; 
							this.range = 1; //TODO: tune me
							this.speed = 0.05;
							this.attack = 1; //TODO: tune me
							this.gObject = new Circle(center, 0.125);
						}

						this.center = this.gObject.center;
						this.right = this.gObject.right;
						this.left = this.gObject.left;
						this.top = this.gObject.top;
						this.bottom = this.gObject.bottom;
					}

					Unit.prototype.mouseDown = function(x, y)
					{
						this.gObject.mouseDown(x, y);
						this.center = this.gObject.center;
						this.right = this.gObject.right;
						this.left = this.gObject.left;
						this.top = this.gObject.top;
						this.bottom = this.gObject.bottom;
					}

					Unit.prototype.update = function()
					{
						this.gObject.update();
						this.center = this.gObject.center;
						this.right = this.gObject.right;
						this.left = this.gObject.left;
						this.top = this.gObject.top;
						this.bottom = this.gObject.bottom;
					}

					Unit.prototype.draw = function(toDraw)
					{
						this.gObject.draw(toDraw);
					}

					Unit.prototype.takeDamage = function(damage)
					{
						this.health -= damage;
						if (this.health == 0)
						{
							console.log("Removing");
							this.remove();
						}
					}

					Unit.prototype.dealDamage = function(opponent)
					{
						opponent.takeDamage(this.attack);
					}

					Unit.prototype.setDestination = function(destination)
					{
						this.gObject.setDestination(destination);
						this.moving = true;
						this.destination = destination;
					}

					Unit.prototype.setPos = function(center)
					{
						this.center = center;
						this.gObject.setPos(center);
						this.right = this.gObject.right;
						this.left = this.gObject.left;
						this.top = this.gObject.top;
						this.bottom = this.gObject.bottom;
					}

					Unit.prototype.inRange = function(other)
					{
						var distance = Math.sqrt(Math.pow(other.center[0] - this.center[0], 2) + Math.pow(other.center[1] - this.center[1], 2));
						if(distance < this.range)
						{
							return true;
						}
						else
						{
							return false;
						}

					}

					Unit.prototype.in = function(point)
					{
						/*Checks if point is in Unit*/
						if(point[0] < this.gObject.right && point[0] > this.gObject.left && point[1] < this.gObject.top && point[1] > this.gObject.bottom)
						{
							return true;
						}
						else
						{
							return false;
						}
					}

					Unit.prototype.remove = function()
					{
						this.dGroup.remove(this);
					}

					/*======================================================== RESOURCE CLASS======================================================= */

					/*======================================================== BASE CLASS ======================================================= */

					/*========================================================  RECTANGLE CLASS =======================================================*/

					function Rectangle(center, width, height)
					{
						/*
						Class for rectangles
						*/
						this.width = width;
						this.height = height;
						this.setPos(center, width, height);
						this.selected = false;
						this.speed = 0.01; //TODO: tune for different shapes and stuff
					}

					Rectangle.prototype.draw = function(toDraw) //adds its info to the buffer
					{
						var i;
						for (i=0; i < this.screenPos.length; i++)
						{
							toDraw.v[toDraw.index+i] = this.screenPos[i];
						}
						toDraw.index += this.screenPos.length;

						var vbuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                            
						gl.bufferData(gl.ARRAY_BUFFER, toDraw.v, gl.STATIC_DRAW);

						toDraw.index += this.screenPos.length;
					}

					Rectangle.prototype.mouseDown = function(posx, posy)
					{
						//TODO: replace selection to changing the color of the piece
						normalX = 2 * (posx / canvas.width) - 1;
						normalY = -2 * (posy / canvas.height) + 1;
						if (!this.selected)
						{
							if (this.in([normalX, normalY]))
							{
								this.selected = true;
								console.log("Selected");
							} 
							else
							{
								console.log("Not selected");
							}
						}
						else
						{
							if (this.in([normalX, normalY]))
							{
								this.selected = false;
								console.log("deselected");
							} 
							else 
							{
								console.log("moving");
								this.setDestination([normalX, normalY]);
							}
						}
					}

					Rectangle.prototype.update = function()
					{
						/*=================  MOVEMENT =======================*/
						if (this.moving)
						{
							//TODO: add pathfinding code!
							xvector = this.destination[0] - this.center[0]; 
							yvector = this.destination[1] - this.center[1];
							mag = Math.sqrt(xvector * xvector + yvector * yvector);
							xunit = xvector / mag;
							yunit = yvector / mag;
							newPos = [this.center[0] + xunit * this.speed, this.center[1] + yunit * this.speed]
							this.setPos(newPos); 
						}
						if (this.center == this.destination)
						{
							this.moving = false;
						}
					}

					Rectangle.prototype.setDestination = function(destination)
					{
						this.moving = true;
						this.destination = destination;
					}

					Rectangle.prototype.setPos = function(center)
					{
						this.screenPos = [center[0] - (this.width / 2), center[1] + (this.height / 2) * aspect ,
										center[0] + (this.width / 2), center[1] + (this.height / 2) * aspect ,
										center[0] - (this.width / 2), center[1] - (this.height / 2) * aspect ,
										center[0] - (this.width / 2), center[1] - (this.height / 2) * aspect ,
										center[0] + (this.width / 2), center[1] + (this.height / 2) * aspect ,
										center[0] + (this.width / 2), center[1] - (this.height / 2) * aspect ];

						this.center = center;
						this.top = center[1] + (this.height / 2)  * aspect;
						this.bottom = center[1] - (this.height / 2) * aspect;
						this.right = center[0] + (this.width / 2);
						this.left = center[0] - (this.width / 2);
					}

					Rectangle.prototype.in = function(point)
					{
						/*Checks if point is in rectangle*/
						if(point[0] < this.right && point[0] > this.left && point[1] < this.top && point[1] > this.bottom)
						{
							return true;
						}
						else
						{
							return false;
						}
					}

					/*========================================================  TRIANGLE CLASS =======================================================*/

					function Triangle(center, width, height)
					{
						/*
						Class for (equilateral) Triangles
						*/
						this.width = width;
						this.height = height;
						this.setPos(center, width, height);
						this.selected = false;
						this.speed = 0.01; //TODO: tune for different shapes and stuff
					}

					Triangle.prototype.draw = function(toDraw) //adds its info to the buffer
					{
						var i;
						for (i=0; i < this.screenPos.length; i++)
						{
							toDraw.v[toDraw.index+i] = this.screenPos[i];
						}
						toDraw.index += this.screenPos.length;

						var vbuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                            
						gl.bufferData(gl.ARRAY_BUFFER, toDraw.v, gl.STATIC_DRAW);

						toDraw.index += this.screenPos.length;
					}

					Triangle.prototype.mouseDown = function(posx, posy)
					{
						//TODO: replace selection to changing the color of the piece
						normalX = 2 * (posx / canvas.width) - 1;
						normalY = -2 * (posy / canvas.height) + 1;
						if (!this.selected)
						{
							if (this.in([normalX, normalY]))
							{
								this.selected = true;
								console.log("Selected");
							} 
							else
							{
								console.log("Not selected");
							}
						}
						else
						{
							if (this.in([normalX, normalY]))
							{
								this.selected = false;
								console.log("deselected");
							} 
							else 
							{
								console.log("moving");
								this.setDestination([normalX, normalY]);
							}
						}
					}

					Triangle.prototype.update = function()
					{
						/*=================  MOVEMENT =======================*/
						if (this.moving)
						{
							//TODO: add pathfinding code!
							xvector = this.destination[0] - this.center[0]; 
							yvector = this.destination[1] - this.center[1];
							mag = Math.sqrt(xvector * xvector + yvector * yvector);
							xunit = xvector / mag;
							yunit = yvector / mag;
							newPos = [this.center[0] + xunit * this.speed, this.center[1] + yunit * this.speed]
							this.setPos(newPos); 
						}
						if (this.center == this.destination)
						{
							this.moving = false;
						}
					}

					Triangle.prototype.setDestination = function(destination)
					{
						this.moving = true;
						this.destination = destination;
					}

					Triangle.prototype.setPos = function(center)
					{
						this.v1 = [center[0] - (this.width / 2), center[1] - (this.height / 2) * aspect];
						this.v2 = [center[0], center[1] + (this.height / 2) * aspect];
						this.v3 = [center[0] + (this.width / 2), center[1] - (this.height / 2) * aspect];

						this.screenPos = [this.v1[0], this.v1[1] ,
										this.v2[0], this.v2[1] ,
										this.v3[0], this.v3[1] ,
										];

						this.center = center;
						this.top = center[1] + (this.height / 2)  * aspect;
						this.bottom = center[1] - (this.height / 2) * aspect;
						this.right = center[0] + (this.width / 2);
						this.left = center[0] - (this.width / 2);
					}

					Triangle.prototype.in = function(point, test=false)
					{
						if(test)
						{
							console.log("point");
							console.log(point)
							console.log("First");
							console.log(((this.v2[0] - this.v1[0]) / (this.v2[1] - this.v1[1]) * point[1] + this.v1[0] < point[0]));  
							console.log("Second");
							console.log(((this.v2[0] - this.v3[0]) / (this.v2[1] - this.v3[1]) * point[1] + this.v3[0] > point[0])); 
							console.log("Third");
							console.log(((this.v2[1] - this.v1[1]) / (this.v2[0] - this.v1[0]) * point[0] + this.v1[1] < point[1]));
							console.log("Fourth"); 
							console.log(((this.v3[1] - this.v2[1]) / (this.v3[0] - this.v2[0]) * point[0] + this.v2[1] > point[1]));
						}

						//TODO: Remove and replace with triangle's real code
						if(point[0] < this.right && point[0] > this.left && point[1] < this.top && point[1] > this.bottom)
						{
							return true;
						}
						/*Checks if point is in triangle*/
						// if( ((this.v2[0] - this.v1[0]) / (this.v2[1] - this.v1[1]) * point[1] + this.v1[0] < point[0]) && 
						// 	((this.v2[0] - this.v3[0]) / (this.v2[1] - this.v3[1]) * point[1] + this.v3[0] > point[0]) &&
						// 	((this.v2[1] - this.v1[1]) / (this.v2[0] - this.v1[0]) * point[0] + this.v1[1] < point[1]) && 
						// 	((this.v3[1] - this.v2[1]) / (this.v3[0] - this.v2[0]) * point[0] + this.v2[1] > point[1]))
						// {
						// 	return true;
						// }
						else
						{
							return false;
						}
					}

					/*========================================================  CIRCLE CLASS =======================================================*/
					function Circle(center, radius, triangles=10)
					{
						/*
						Class for (equilateral) Circles
						*/
						this.radius = radius;
						this.setPos(center, radius);
						this.selected = false;
						this.speed = 0.01; //TODO: tune for different shapes and stuff
						this.triangles=triangles; //number of triangles used to create a circle
					}

					Circle.prototype.draw = function(toDraw) //adds its info to the buffer
					{
						var i;
						for (i=0; i < this.screenPos.length; i++)
						{
							toDraw.v[toDraw.index+i] = this.screenPos[i];
						}
						toDraw.index += this.screenPos.length;

						var vbuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                            
						gl.bufferData(gl.ARRAY_BUFFER, toDraw.v, gl.STATIC_DRAW);

						toDraw.index += this.screenPos.length;
					}

					Circle.prototype.mouseDown = function(posx, posy)
					{
						//TODO: replace selection to changing the color of the piece
						normalX = 2 * (posx / canvas.width) - 1;
						normalY = -2 * (posy / canvas.height) + 1;
						if (!this.selected)
						{
							if (this.in([normalX, normalY]))
							{
								this.selected = true;
								console.log("Selected");
							} 
							else
							{
								console.log("Not selected");
							}
						}
						else
						{
							if (this.in([normalX, normalY]))
							{
								this.selected = false;
								console.log("deselected");
							} 
							else 
							{
								console.log("moving");
								this.setDestination([normalX, normalY]);
							}
						}
					}

					Circle.prototype.update = function()
					{
						/*=================  MOVEMENT =======================*/
						if (this.moving)
						{
							//TODO: add pathfinding code!
							xvector = this.destination[0] - this.center[0]; 
							yvector = this.destination[1] - this.center[1];
							mag = Math.sqrt(xvector * xvector + yvector * yvector);
							xunit = xvector / mag;
							yunit = yvector / mag;
							newPos = [this.center[0] + xunit * this.speed, this.center[1] + yunit * this.speed]
							this.setPos(newPos); 
						}
						if (this.center == this.destination)
						{
							this.moving = false;
						}
					}

					Circle.prototype.setDestination = function(destination)
					{
						this.moving = true;
						this.destination = destination;
					}

					Circle.prototype.setPos = function(center)
					{
						// this.v1 = [center[0] - (this.width / 2), center[1] - (this.height / 2) * aspect];
						// this.v2 = [center[0], center[1] + (this.height / 2) * aspect];
						// this.v3 = [center[0] + (this.width / 2), center[1] - (this.height / 2) * aspect];
						var newScreenPos = [];
						var i;
						var wedgesize = 2 * Math.PI / 10;
						var theta = 0;
						for(i = 0; i < 20; i++)
						{
							console.log(theta);
							newScreenPos.push(center[0]); newScreenPos.push(center[1]);
							newScreenPos.push(center[0] + this.radius * Math.cos(theta)); newScreenPos.push(center[1] + (this.radius * Math.sin(theta)) * aspect);
							theta += wedgesize;
							newScreenPos.push(center[0] + this.radius * Math.cos(theta)); newScreenPos.push(center[1] + (this.radius * Math.sin(theta)) * aspect);
						}
						console.log(newScreenPos);
						this.screenPos = newScreenPos;

						this.center = center;
						this.top = center[1] + (this.radius)  * aspect;
						this.bottom = center[1] - (this.radius) * aspect;
						this.right = center[0] + (this.radius);
						this.left = center[0] - (this.radius);
					}

					Circle.prototype.in = function(point, test=false)
					{

						//TODO: Remove and replace with Circle's real code
						if(point[0] < this.right && point[0] > this.left && point[1] < this.top && point[1] > this.bottom)
						{
							return true;
						}
						/*Checks if point is in Circle*/
						// if( ((this.v2[0] - this.v1[0]) / (this.v2[1] - this.v1[1]) * point[1] + this.v1[0] < point[0]) && 
						// 	((this.v2[0] - this.v3[0]) / (this.v2[1] - this.v3[1]) * point[1] + this.v3[0] > point[0]) &&
						// 	((this.v2[1] - this.v1[1]) / (this.v2[0] - this.v1[0]) * point[0] + this.v1[1] < point[1]) && 
						// 	((this.v3[1] - this.v2[1]) / (this.v3[0] - this.v2[0]) * point[0] + this.v2[1] > point[1]))
						// {
						// 	return true;
						// }
						else
						{
							return false;
						}
					}
			</script>
	</head>
	<body onload="init()">
			<canvas id="mycanvas" width="800" height="500"></canvas>
	</body>
</html>
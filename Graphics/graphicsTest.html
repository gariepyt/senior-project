 <html>
	<head>
		    <meta charset="utf-8">
		    <meta http-equiv="X-UA-Compatible" content="IE=edge">
		    <meta name="viewport" content="width=device-width, initial-scale=1">
		    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
		    <meta name="description" content="">
		    <meta name="author" content="">
		    <link rel="icon" href="icon.ico">

		    <title>Rock-Paper-Scissors RTS</title>

		    <!-- Bootstrap core CSS -->
		    <link href="css/bootstrap.min.css" rel="stylesheet">
		    <!-- Bootstrap theme -->
		    <link href="css/bootstrap-theme.min.css" rel="stylesheet">

		    <!-- Custom styles for this template -->
		    <link href="css/theme.css" rel="stylesheet">

		    <!-- Custom styles for this template -->
		    <link href="css/starter-template.css" rel="stylesheet">

		    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
		    <!--[if lt IE 9]>
		      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
		      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
		    <![endif]-->
		    <!--Popup Window Code -->
		    <script type="text/javascript"> 
		      function popup(mylink, windowname) { 
		        if (!window.focus) {
		          return true;
		        }        
		        var href; 
		        if (typeof(mylink) == 'string') {
		          href=mylink;
		        }  else {
		          href=mylink.href;
		        }
		        window.open(href, windowname, 'width=600,height=300,scrollbars=yes'); 
		        return false; }
		    </script>           
			<script id="vertex" type="x-shader">
				attribute vec2 aVertexPosition;
				void main() 
				{
					gl_Position = vec4(aVertexPosition, 0.0, 1.0);
				}
			</script>  

			<script id="fragment" type="x-shader">
				    #ifdef GL_ES
					precision highp float;
					#endif
					uniform vec4 uColor;
					                       
					void main() 
					{
						gl_FragColor = uColor;
					}
			</script>
			<script src="js.cookie.js"></script>        
			<script type="text/javascript">

					var gl;
					var aspect;
					//var vbuffer;
					var program;
					var p1;
					var p2;
					var resourcesList;

					function resize()
					{
						canvas.width = window.innerWidth * 0.75;
						canvas.height = window.innerHeight * 0.75;
						//set up arrays
						aspect = canvas.width / canvas.height;
					}

					function addResources()
					{
						for (i = 0; i < resourcesList.length; i++)
						{	
							resource = resourcesList[i];
							if (resource.player != null)
							{
								console.log("yep");
								if( resource.shape == "rectangle")
								{
									resource.player.rock += resource.acquireRate;
								}
								else if(resource.shape == "triangle")
								{
									resource.player.scissors += resource.acquireRate;
								}
								else if(resource.shape == "circle")
								{
									resource.player.paper += resource.acquireRate;									
								}
							}
						}
					}

					function init()
					{
						canvas = document.getElementById("mycanvas");
						resize();
						/*========================= CAPTURE MOUSE EVENTS ========================= */
						var drag=false;
						var old_x, old_y;
						var down_x, down_y, up_x, up_y;
						var mouseDownEvent;
						var mouseUpEvent;
						var mouseButton = -1;
						var keyboardEvent = null;
						var shortClick = true;
						var timeoutHandle; 

						var clickLength = function()
						{
							shortClick=false;
						};

						var mouseDown=function(e) 
						{
							mouseUpEvent = false;
							mouseDownEvent = true;
							mouseButton = e.button;
							drag = true;							
							old_x = e.pageX, old_y = e.pageY;
							down_x = old_x;
							down_y = old_y;
							timeoutHandle = setTimeout(clickLength, 300);
							e.preventDefault();
							return false;
						};

						var mouseUp=function(e)
						{
							up_x = e.pageX;
							up_y = e.pageY;
							clearTimeout(timeoutHandle);
							mouseUpEvent = true;
							mouseDownEvent = false;
							drag=false;
							e.preventDefault();
						};

						var mouseMove=function(e) 
						{
							if (!drag) return false;
							var dX=e.pageX-old_x,
							    dY=e.pageY-old_y;
							// THETA+=dX*2*Math.PI/canvas.width;
							// PHI+=dY*2*Math.PI/canvas.height;
							old_x=e.pageX, old_y=e.pageY;
							e.preventDefault();
						};

						var keyboardEvents=function(e)
						{
							keyboardEvent = e;
						}
						
						canvas.addEventListener("mousedown", mouseDown, false);
						canvas.addEventListener("mouseup", mouseUp, false);
						canvas.addEventListener("mouseout", mouseUp, false);
						canvas.addEventListener("mousemove", mouseMove, false);
						document.addEventListener("keydown", keyboardEvents, false);

						document.addEventListener("contextmenu", function(e) {
													e.preventDefault();
													});

						/*========================= CANVAS AND SHADERS ========================= */
					    gl = canvas.getContext("experimental-webgl"); //
						gl.viewport(0, 0, canvas.width, canvas.height);
						gl.clearColor(0, 0, 0, 1); //drawing viewfinder color
						gl.clear(gl.COLOR_BUFFER_BIT);
						
			    		var v = document.getElementById("vertex").firstChild.nodeValue;
						var f = document.getElementById("fragment").firstChild.nodeValue;
						 
						var vs = gl.createShader(gl.VERTEX_SHADER);
						gl.shaderSource(vs, v);
						gl.compileShader(vs);
						
						var fs = gl.createShader(gl.FRAGMENT_SHADER);
						gl.shaderSource(fs, f);
						gl.compileShader(fs);
						
						program = gl.createProgram();
						gl.attachShader(program, vs);
						gl.attachShader(program, fs);
						gl.linkProgram(program);

						if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
							console.log(gl.getShaderInfoLog(vs));

						if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
							console.log(gl.getShaderInfoLog(fs));

						if (!gl.getProgramParameter(program, gl.LINK_STATUS))
							console.log(gl.getProgramInfoLog(program));

						maxUnits = 100; //temp
						var innerSelectionBox = new DrawGroup(10, [0, 0, 0, 1.0]);
						var outerSelectionBox = new DrawGroup(10, [1.0, 1.0, 1.0, 1.0]);
						var neutralResources = new DrawGroup(maxUnits, [1.0, 1.0, 1.0, 1.0]); 
						var p1Owned = new DrawGroup(maxUnits, [0.0, 0.0, 1.0, 1.0]); 
						var p2Owned = new DrawGroup(maxUnits, [1.0, 0.0, 0.0, 1.0]); 
						var p1Selected = new DrawGroup(maxUnits, [0.52, 0.8, 0.92, 1.0]);
						var p2Selected = new DrawGroup(maxUnits, [1.0, 0.41, 0.70, 1.0]);

						/* Getting difficulty from user */
						var corNum = false;
						var diffNum = 1;
						while (corNum == false) {
							diffNum = prompt("Select difficulty in range 1 (easy) - 5 (hard)", "1");
							if (!isNaN(diffNum)) { // is a number
								diffNum = Number(diffNum);
								if (diffNum >= 1 && diffNum <= 5) {
									corNum = true;
								}
								else {
									alert(diffNum + " is out of range!");
								}
							}
							else {
								alert(diffNum + " is not a number!");
							}
						}


						p1 = new Player(true);
						p1.standard = p1Owned;
						p1.selected = p1Selected;						
						p2 = new Player(false, diffNum);
						p2.standard = p2Owned;
						p2.selected = p2Selected;
						var myGroups = [neutralResources, p1.standard, p2.standard, p1.selected, p2.selected];

						if (Cookies.get('gameid')) {
							getFiles(Cookies.get('gameid'));

							var httpRequest = new XMLHttpRequest();
							var url = "http://web.engr.oregonstate.edu/~sibailaj/framework/handler.php?gameid=" + Cookies.get('gameid');
							var unitObject = new Object();

							if (httpRequest) {
								httpRequest.onreadystatechange = handle;
								httpRequest.open('GET', url, true);
								httpRequest.send();
							}

							function handle() {
								if (httpRequest.readyState === httpRequest.DONE) {
									if (httpRequest.status === 200) {
										//Parse JSON Data
										unitObject = JSON.parse(httpRequest.responseText);
										loadGame(p1, p2, unitObject);
										//loadGame(p1, p2, unitObject);
									}
								}
							}



							r1 = new Resource([0, 0], "rectangle");
							r2 = new Resource([-0.5, 0], "triangle");
							r3 = new Resource([0.5, 0], "circle");
							resourcesList = [r1, r2, r3];

							b1 = new Base([0, -0.75], p1);
							b2 = new Base([0, 0.75], p2);

							// outerSelectionBox.add(new Rectangle([-.25, -.25], .03, .03));

							var temp_b1 = JSON.parse(Cookies.get('b1'));
							var temp_b2 = JSON.parse(Cookies.get('b2'));

							b1.health = temp_b1.health;
							b2.health = temp_b2.health;

							neutralResources.add(r1);
							neutralResources.add(r2);
							neutralResources.add(r3);

							p1Owned.add(b1);
							p2Owned.add(b2);

						} else {							
							r1 = new Resource([0, 0], "rectangle");
							r2 = new Resource([-0.5, 0], "triangle");
							r3 = new Resource([0.5, 0], "circle");
							resourcesList = [r1, r2, r3];

							b1 = new Base([0, -0.75], p1);
							b2 = new Base([0, 0.75], p2);

							// outerSelectionBox.add(new Rectangle([-.25, -.25], .03, .03));

							neutralResources.add(r1);
							neutralResources.add(r2);
							neutralResources.add(r3);

							p1Owned.add(b1);
							p2Owned.add(b2);

							p1.spawnRock(p1.standard, p1.standard);
							p1.spawnPaper(p1.standard, p1.standard);
							p1.spawnScissors(p1.standard, p1.standard);
							p2.spawnRock(p2.standard, p2.standard);
							p2.spawnPaper(p2.standard, p2.standard);
							p2.spawnScissors(p2.standard, p2.standard);
						}

						var combinedGroup;
						function update()
						{
							var i; var j; 
							combinedGroup = new DrawGroup(maxUnits * myGroups.length, [0.0, 1.0, 0.0, 1.0])
							for(i=0; i < myGroups.length; i++)
							{
								for(j=0; j < myGroups[i].group.length; j++)
								{
									combinedGroup.group.push(myGroups[i].group[j]);
								}
							}

							/*========================== USER EVENTS ==================================*/
							if (mouseUpEvent)
							{
								mouseDownEvent = false;
								mouseUpEvent = false;
								if (!shortClick)
								{
									if (innerSelectionBox.group.length > 0)
									{
										innerSelectionBox.remove(innerSelectionBox.group[0]);
									}
									if (outerSelectionBox.group.length > 0)
									{
										outerSelectionBox.remove(outerSelectionBox.group[0]);
									}

									shortClick = true;
									var corner1x = 2 * (up_x / canvas.width) - 1;
									var corner1y = -2 * (up_y / canvas.height) + 1;
									var corner2x = 2 * (down_x / canvas.width) - 1;
									var corner2y = -2 * (down_y / canvas.height) + 1;
									if (corner2x > corner1x)
									{
										var width = corner2x - corner1x;
										var centerx = width / 2 + corner1x;
									}
									else
									{
										var width = corner1x - corner2x;
										var centerx = width / 2 + corner2x;
									}
									if (corner2y > corner1y)
									{
										var height = corner2y - corner1y;
										var centery =  height / 2 + corner1y;
									}
									else
									{
										var height = corner1y - corner2y;
										var centery = height / 2 + corner2y;
									}

									var selectAllRect = new Rectangle([centerx, centery], width, height);
									var topRight = [selectAllRect.right, selectAllRect.top]; 
									var topLeft = [selectAllRect.left, selectAllRect.top];
									var bottomRight = [selectAllRect.right, selectAllRect.bottom];
									var bottomLeft = [selectAllRect.left, selectAllRect.bottom];
									for(i = 0; i < combinedGroup.group.length; i++)
									{
										if (combinedGroup.group[i].constructor.name == 'Unit' && combinedGroup.group[i].owner == p1)
										{
											var iTopRight = [combinedGroup.group[i].right, combinedGroup.group[i].top]; 
											var iTopLeft = [combinedGroup.group[i].left, combinedGroup.group[i].top];
											var iBottomRight = [combinedGroup.group[i].right, combinedGroup.group[i].bottom];
											var iBottomLeft = [combinedGroup.group[i].left, combinedGroup.group[i].bottom];
											if(combinedGroup.group[i].in(topRight) || combinedGroup.group[i].in(topLeft) ||
												combinedGroup.group[i].in(bottomRight) || combinedGroup.group[i].in(bottomLeft) ||
												combinedGroup.group[i].in(selectAllRect.center) ||
												selectAllRect.in(iTopRight) || selectAllRect.in(iTopLeft) || 
												selectAllRect.in(iBottomRight) || selectAllRect.in(iBottomLeft) ||
												selectAllRect.in(combinedGroup.group[i].center))
											{
												combinedGroup.group[i].select();
											}
										}
									}									
								}
								else
								{
									//FOR UNIT SPECIFIC MOUSE EVENTS
									var clickedSomeEntity = false;
									for(i=0; i < combinedGroup.group.length; i++)
									{
										if (combinedGroup.group[i].constructor.name == "Unit" && 
											combinedGroup.group[i].owner == p1)
										{
											if (mouseButton	== 0)
											{
												if (combinedGroup.group[i].click(old_x, old_y))
												{
													clickedSomeEntity = true;
												}
											}
											else if (mouseButton == 2)
											{
												combinedGroup.group[i].rightClick(old_x, old_y);
											}
										}
									}
									if (!clickedSomeEntity && shortClick && mouseButton == 0)
									{
										//need conditional for checking nothing was clicked
										var temp;
										while (p1Selected.group.length > 0)
										{
											temp = p1Selected.group[0];
											temp.deselect();
										}
									}
								}
							}
							else if (mouseDownEvent && !shortClick)
							{
								var corner1x = 2 * (old_x / canvas.width) - 1;
								var corner1y = -2 * (old_y / canvas.height) + 1;
								var corner2x = 2 * (down_x / canvas.width) - 1;
								var corner2y = -2 * (down_y / canvas.height) + 1;
								if (corner2x > corner1x)
								{
									var width = corner2x - corner1x;
									var centerx = width / 2 + corner1x;
								}
								else
								{
									var width = corner1x - corner2x;
									var centerx = width / 2 + corner2x;
								}
								if (corner2y > corner1y)
								{
									var height = corner2y - corner1y;
									var centery =  height / 2 + corner1y;
								}
								else
								{
									var height = corner1y - corner2y;
									var centery = height / 2 + corner2y;
								}
								
								if (innerSelectionBox.group.length > 0)
								{
									innerSelectionBox.remove(innerSelectionBox.group[0]);
								}
								if (outerSelectionBox.group.length > 0)
								{
									outerSelectionBox.remove(outerSelectionBox.group[0]);
								}
								
								var innerSelectingRect = new Rectangle([centerx, centery], width, height);
								var outerSelectingRect = new Rectangle([centerx, centery], width + 0.001, height + 0.001);
								innerSelectionBox.add(innerSelectingRect);
								outerSelectionBox.add(outerSelectingRect);
							}

							if (keyboardEvent != null)
							{
								p1.handleEvents(keyboardEvent, p1.standard, combinedGroup);
								keyboardEvent = null;
							}

							/*====================== COLLISON CHECKS ================================*/
							combinedGroup.checkForCollisions(); 

							/*============================ CHECK ATTACKS ==========================*/
							for(i=0; i < combinedGroup.group.length; i++)
							{
								for(j=0; j < combinedGroup.group.length; j++)
								{
									if(i != j && combinedGroup.group[i].constructor.name == "Unit")
									{	
										if (combinedGroup.group[i].inRange(combinedGroup.group[j]) && 
											(combinedGroup.group[i].owner != combinedGroup.group[j].owner) && 
											(combinedGroup.group[j].constructor.name == "Unit" || combinedGroup.group[j].constructor.name=='Base'))
										{
											combinedGroup.group[i].dealDamage(combinedGroup.group[j]);
										}
										else
										{
											//TODO: end attacking animation
										}
									}
								}
							}


							/*========================== UPDATES ==================================*/
							/* Update AI and Player points as well */
							for(i=0; i < combinedGroup.group.length; i++)
							{
								combinedGroup.group[i].update()
							}
							p1.update();
							p2.update(p1, neutralResources);
						}

						function drawLoop()
						{
							var i; var j;
							gl.clear(gl.COLOR_BUFFER_BIT);							
							for(i=0; i < myGroups.length; i++)
							{
								myGroups[i].clear();
							}
							outerSelectionBox.clear();
							innerSelectionBox.clear();

							for(j=0; j < outerSelectionBox.group.length; j++)
							{
								outerSelectionBox.group[j].draw(outerSelectionBox);
							}
							outerSelectionBox.render();
							for(j=0; j < innerSelectionBox.group.length; j++)
							{
								innerSelectionBox.group[j].draw(innerSelectionBox);
							}
							innerSelectionBox.render();

							for(i=0; i < myGroups.length; i++)
							{
								for(j=0; j < myGroups[i].group.length; j++)
								{
									myGroups[i].group[j].draw(myGroups[i]);
								}
								myGroups[i].render();
							}														
						}

						setInterval(update, 1);
						setInterval(addResources, 1000);
						setInterval(drawLoop, 16);

						/*========================================================  LOAD GAME =======================================================*/
						function loadGame(p1, p2, unitObject) {
							var i;
							//Retrieve Unit Data from Server
							//var unitObject = new Object();
							//unitObject = getFiles(Cookies.get('gameid'));

							//Separate p1 and p2 Units
							var p2_units = getUnits(unitObject, false);
							var p1_units = getUnits(unitObject, true);

							for (i = 0; i < p1_units.length; i++) {
								p1.loadUnit(p1.standard, p1_units[i]);
							}

							for (i = 0; i < p2_units.length; i++) {
								p2.loadUnit(p2.standard, p2_units[i]);
							}

							//p1.standard.group.push(p1_units[0]);

							//Restore Players
							//p1 = restorePlayer(p1, p1_units);
							//p2 = restorePlayer(p2, p2_units);

							//Restore Resources
				        	//r1 = JSON.parse(JSON.stringify(Cookies.get('r1')));
				        	//r2 = JSON.parse(JSON.stringify(Cookies.get('r2')));
				        	//r3 = JSON.parse(JSON.stringify(Cookies.get('r3')));

				        	//Restore Bases
				        	//b1 = JSON.parse(JSON.stringify(Cookies.get('b1')));
				        	//b2 = JSON.parse(JSON.stringify(Cookies.get('b2')));						

							function getUnits(unitObject, human) {
								var x;
								var unit;
								var playerUnits = [];

								for (x = (unitObject.length - 1); x > -1; x--) {
									if (unitObject[x].human == human) {
										unit = unitObject.pop();
										playerUnits.push(unit);
									}
								}
								return playerUnits;
							}

							function restorePlayer(p, unitObject) {
								var s;
								if (p.human == true) {
									s = JSON.parse(Cookies.get('p1'));
								} else {
									s = JSON.parse(Cookies.get('p2'));
								}
								var x;
								var unit;
								s.standard.v = p.standard.v;

								//Add Units to Instance
					        	if (s.hasOwnProperty("standard")) {
						        	if (s.standard.hasOwnProperty("group")) {
						        		s.standard.group.push(unitObject);

						        		/*
							        	for (x = 0; x < s.standard.group.length; x++) {
							        		if (s.standard.group[x] == null) {							    
							        			//Pop unitObject array for human 
							        			//and set equal to p.standard.group[x]
							        			unit = unitObject.pop();
							        			s.standard.group[x] = unit;
							        		}
							        		s.standard.group[x].dGroup = s.standard;
							        		s.standard.group[x].owner = s;							        
							        	}
							        	*/
						        	}
						        }

								//return s;
							}
						}

				        /*========================================================  NEW GAME =======================================================*/
				        var newButton = document.getElementById('new');
				        newButton.onclick = function() {
				        	Cookies.remove('gameid');
				        	document.location.reload(true);
				        }

				        /*========================================================  SAVE GAME =======================================================*/
				        var saveButton = document.getElementById("save");
				        var gameid;
				        saveButton.onclick = function() {
					        if (Cookies.get('gameid')) {
					        	//Use Existing Game ID
					            gameid = Cookies.get('gameid');

					            //Pass in Player Instances
					            //Units will be sent to server
					            //All other data will be saved as cookies
					            prepData(gameid, p1, p2, r1, r2, r3, b1, b2);

					        } else {
					            //Get New Game ID from server
					            var httpRequest = new XMLHttpRequest();
					            var url = "http://web.engr.oregonstate.edu/~sibailaj/framework/createid.php";
					            var newid;

					            if (httpRequest) {
					        	    httpRequest.onreadystatechange = handle;
					            	httpRequest.open('GET', url, true);
					            	httpRequest.send();
					            }

					            function handle() {
					                if (httpRequest.readyState === httpRequest.DONE && httpRequest.status === 200) {

					                	//Set id cookie
					                	gameid = httpRequest.responseText;
					                	Cookies.set('gameid', gameid);

					                	//Pass in Player Instances
					                	//Units will be sent to server
					                	//All other data will be saved as cookies
					                	prepData(gameid, p1, p2, r1, r2, r3, b1, b2);
					                }
					                else {
					                  //alert("Error: Bad Request");
					                }
					            }					            
					        }
				        }
					}

					/*================== DRAW GROUP =================*/
					function DrawGroup(maxUnits, color=[])
					{
						this.v = new Float32Array(maxUnits*12);
						var i;
						for(i=0; i < this.v.length; i++)
						{
							this.v[i] = 0;
						}
						this.index = 0;
						this.group = [];
						this.color = color;
					}

					DrawGroup.prototype.add = function(toAdd)
					{
						toAdd.dGroup = this;
						toAdd.index = this.group.length;
						this.group.push(toAdd); 						
					}

					DrawGroup.prototype.remove = function(toRemove)
					{
						var i;
						var oldGroup = this.group;
						this.index = 0;
						this.group = [];
						for(i = 0; i < oldGroup.length; i++)
						{
							oldGroup[i].dGroup = null;
							if (toRemove != oldGroup[i])
							{
								this.add(oldGroup[i]);
							}
						}						
					}

					DrawGroup.prototype.render = function()
					{
						if (this.group.length != 0)
						{
							itemSize = 2;
							numItems = this.v.length / itemSize;

							//gl
							gl.useProgram(program);
	     
							program.uColor = gl.getUniformLocation(program, "uColor"); //get color from program
							gl.uniform4fv(program.uColor, this.color); //set color
							program.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"); //get vertex position from program
							gl.enableVertexAttribArray(program.aVertexPosition);
							gl.vertexAttribPointer(program.aVertexPosition, itemSize, gl.FLOAT, false, 0, 0);
							gl.drawArrays(gl.TRIANGLES, 0, numItems);
						}
						
					}

					DrawGroup.prototype.clear = function()
					{
						var i;
						for (i=0; i < this.v.length; i++)
						{
							if(this.v[i] != 0)
							{
								this.v[i] = 0;
							}
						}
						this.index = 0;
					}

					DrawGroup.prototype.checkForCollisions = function()
					{
						var i; var j;
						for (i=0; i < this.group.length; i++) //pairwise comparison
						{
							for(j=0; j < this.group.length; j++)
							{
								if(j != i)
								{
									var iTopRight = [this.group[i].right, this.group[i].top]; 
									var iTopLeft = [this.group[i].left, this.group[i].top];
									var iBottomRight = [this.group[i].right, this.group[i].bottom];
									var iBottomLeft = [this.group[i].left, this.group[i].bottom];
									
									if(this.group[j].in(iTopRight) || this.group[j].in(iTopLeft) ||
										this.group[j].in(iBottomRight) || this.group[j].in(iBottomLeft) ||
										this.group[j].in(this.group[i].center))
									{
										this.group[i].collisionTrigger(this.group[j]);

										//TODO: resume moving once obstacle is moved. pathfinding related
									}
								}
							}
						}
					}

					DrawGroup.prototype.somethingCollidesWith = function(entity)
					{
						var j;
						for(j=0; j < this.group.length; j++) //check for collisions
						{
							if(entity.center != this.group[j].center)
							{
								var iTopRight = [entity.right, entity.top]; 
								var iTopLeft = [entity.left, entity.top];
								var iBottomRight = [entity.right, entity.bottom];
								var iBottomLeft = [entity.left, entity.bottom];
								
								if(this.group[j].in(iTopRight) || this.group[j].in(iTopLeft) ||
									this.group[j].in(iBottomRight) || this.group[j].in(iBottomLeft) ||
									this.group[j].in(entity.center))
								{
									return true;
								}
							}
						}
						return false;
					}

					/*========================================================  PLAYER CLASS =======================================================*/

					function Player(human, difficulty=null)
					{
						/*ai: boolean determining whether or not this is the ai player*/
						var s;
						this.human = human;
						if (human == false) {
							this.difficulty = difficulty;
							this.toIdle();
							this.statusCount = 500;
						}

						//RESOURCES
						if (Cookies.get('gameid')) {
							if (this.human == true) {
								s = JSON.parse(Cookies.get('p1'));
								this.paper = s.paper;
								this.rock = s.rock;
								this.scissors = s.scissors;
							} else {
								s = JSON.parse(Cookies.get('p2'));
								this.paper = s.paper;
								this.rock = s.rock;
								this.scissors = s.scissors;
							}
						} else {
							this.rock = 200;
							this.paper = 200;
							this.scissors = 200;
						}
					}

					Player.prototype.spawnRock = function(drawGroup, colliders=null)
					{
						//TODO: spawn in different location if colliding
						var cost = 50; //TODO: tune me
						if (this.rock > cost)
						{
							this.rock -= cost;
							//TODO: spawn position based on whether or not is human
							if (this.human)
							{
								if (colliders == null)
								{
									drawGroup.add(new Unit([0,-0.75], "rectangle", this));
								}
								else
								{
									var pos = [0,-0.75];
									var toAdd = new Unit(pos, "rectangle", this);
									while (colliders.somethingCollidesWith(toAdd))
									{
										pos[0] += 0.1;
										toAdd = new Unit(pos, "rectangle", this);
									}
									drawGroup.add(toAdd);
								}
							}
							else
							{
								if (colliders == null)
								{
									drawGroup.add(new Unit([0,0.75], "rectangle", this));
								}
								else
								{
									var pos = [0,0.75];
									var toAdd = new Unit(pos, "rectangle", this);
									while (colliders.somethingCollidesWith(toAdd))
									{
										pos[0] += 0.1;
										toAdd = new Unit(pos, "rectangle", this);
									}
									drawGroup.add(toAdd);
								}
							}
						}
						else
						{
							console.log("Not enough rock resources");
						}
					}

					Player.prototype.loadUnit = function(drawGroup, u, colliders=null)
					{
						drawGroup.add(new Unit(u.center, u.shape, this, u, false));						
					}

					Player.prototype.spawnPaper = function(drawGroup, colliders=null)
					{
						//TODO: spawn in different location if colliding
						var cost = 50; // TODO: tune me
						if (this.paper > cost)
						{
							this.paper -= cost;
							if (this.human)
							{
								if (colliders == null)
								{
									drawGroup.add(new Unit([0,-0.75], "circle", this));
								}
								else
								{
									var pos = [0,-0.75];
									var toAdd = new Unit(pos, "circle", this);
									while (colliders.somethingCollidesWith(toAdd))
									{
										pos[0] += 0.1;
										toAdd = new Unit(pos, "circle", this);
									}
									drawGroup.add(toAdd);
								}
							}
							else
							{
								if (colliders == null)
								{
									drawGroup.add(new Unit([0,0.75], "circle", this));
								}
								else
								{
									var pos = [0,0.75];
									var toAdd = new Unit(pos, "circle", this);
									while (colliders.somethingCollidesWith(toAdd))
									{
										pos[0] += 0.1;
										toAdd = new Unit(pos, "circle", this);
									}
									drawGroup.add(toAdd);
									
								}
							}
						}
					}

					Player.prototype.spawnScissors = function(drawGroup, colliders=null)
					{
						//TODO: spawn in different location if colliding
						var cost = 50; // TODO: tune me
						if (this.scissors > cost)
						{
							this.scissors -= cost;
							if (this.human)
							{
								if (colliders == null)
								{
									drawGroup.add(new Unit([0,-0.75], "triangle", this));
								}
								else
								{
									var pos = [0,-0.75];
									var toAdd = new Unit(pos, "triangle", this)
									while (colliders.somethingCollidesWith(toAdd))
									{
										pos[0] += 0.1;
										toAdd = new Unit(pos, "triangle", this);
									}
									drawGroup.add(toAdd);
								}
							}
							else
							{
								if (colliders == null)
								{
									drawGroup.add(new Unit([0,0.75], "triangle", this));
								}
								else
								{
									var pos = [0,0.75];
									var toAdd = new Unit(pos, "triangle", this)
									while (colliders.somethingCollidesWith(toAdd))
									{
										pos[0] += 0.1;
										toAdd = new Unit(pos, "triangle", this);
									}
									drawGroup.add(toAdd);
								}
							}
						}
					}

					Player.prototype.handleEvents = function(e, toDraw, colliders)
					{
						if (e.keyCode == 81)
						{
							this.spawnRock(toDraw, colliders);
						}
						else if (e.keyCode == 87)
						{
							this.spawnPaper(toDraw, colliders);
						}
						else if (e.keyCode == 69)
						{
							this.spawnScissors(toDraw, colliders);
						}
					}

					Player.prototype.update = function(enemy=null, resources=null) {
						if (this.human == false) { // This is the AI, which means we need to move the pieces
							// console.log("This is the enemy!");
							// console.log("Enemy size: " + this.standard.group.length);

							/* If not in defend mode, loop through all the players and randomly decide what to do (if they are not already doing something) */
							if (this.status != "defend") {
								if (this.statusCount == 0) {
									// Options: attack base, attack player, harvest, or do nothing
									for (var x = 1; x < this.standard.group.length; x++) {
										/* Roll a rand */
										var randRoll = Math.floor(Math.random() * 4);
										console.log("Enemy rolled: " + randRoll);
										if (randRoll == 0) { // Attack the base
											this.standard.group[x].setDestination(enemy.standard.group[0].center);
										}
										else if (randRoll == 1) { // Attack a random player
											var randPlayer = Math.floor(Math.random() * (enemy.standard.group.length - 1) + 1);
											this.standard.group[x].setDestination(enemy.standard.group[randPlayer].center);
										}
										else if (randRoll == 2) { // Harvest
											var randHarv = Math.floor(Math.random() * (resources.group.length));
											if(resources.group[randHarv].owner != this) {
												this.standard.group[x].setDestination(resources.group[randHarv].center);
											}
											
										}
										else {
											/* Do nothing */
										}

										/* Randomly decide if new item will be created */
										var randResDecide = Math.floor(Math.random() * (15000 / (this.difficulty * this.difficulty)));
										if (randResDecide < 600) {
											var randResources = Math.floor(Math.random() * 2);
											if (randResources) {
												this.spawnRock(this.standard, this.standard);
											}

											randResources = Math.floor(Math.random() * 2);
											if (randResources) {
												this.spawnPaper(this.standard, this.standard);
											}

											randResources = Math.floor(Math.random() * 2);
											if (randResources) {
												this.spawnScissors(this.standard, this.standard);
											}
										}

										this.toIdle();
									}

								}
								else {
									console.log("Counting down");
									this.statusCount--;
								}


							}
							else { // AI is in defend mode
								if (this.statusCount >= 0) {
									this.statusCount--;
								}
								else {
									this.toIdle();
								}	
							}





						}
						else { // This is the human, which means we need to update their inventory
							document.getElementById("rock resource").innerHTML = "Rock: " + this.rock;
							document.getElementById("scissors resource").innerHTML = "Scissors: " + this.scissors;
							document.getElementById("paper resource").innerHTML = "Paper: " + this.paper;
						}
					}

					Player.prototype.toIdle = function() {
						this.status = "idle";
						this.statusCount = 2000 / this.difficulty; // This might be too slow
					}

					Player.prototype.defendBase = function() {
						if (this.human == false) {
							console.log("The base is under attack!");

							if (this.status != "defend") {
								this.status = "defend";
								this.statusCount = 1000 * this.difficulty;
								/* Decide if the AI will move the pieces to defend the base */
								for (var x = 1; x < this.standard.group.length; x++){
									var randCheck = Math.floor(Math.random() * (5 + this.difficulty)); // Is this a good setting?
									if (randCheck >= 5) { // Is this a good setting?
										this.standard.group[x].setDestination(this.standard.group[0].center);
									}
								}
								
							}
							else {
								/* NOTE: this should be happening in the update instead! It should reset the number instead */
								this.statusCount = 1000 * this.difficulty;
							}
							

							console.log("Enemy size: " + this.standard.group.length);
							for (var x = 1; x < this.standard.group.length; x++) {
								console.log("Enemy " + x + " type: " + this.standard.group[x].shape);
							}
							// for (var x = 0; x < p1.)
						}
					}

					/*========================================================  UNIT CLASS =======================================================*/

					function Unit(center, shape, owner, s, newUnit)
					{
						this.owner = owner; //determines whether this belongs to the player or the AI
						this.selected = false;

						this.shape = shape;
						if(this.shape == "rectangle")
						{
							if (Cookies.get('gameid') && (newUnit == false)) {
								this.health = s.health;
								this.range = s.range;
								this.speed = s.speed;
								this.attack = s.attack;
								this.gObject = new Rectangle(center, 0.0625, 0.0625);
								this.gObject.center = s.center;
								this.gObject.right = s.right;
								this.gObject.left = s.left;
								this.gObject.top = s.top;
								this.gObject.bottom = s.bottom;
							} else {
								this.health = 1500; 
								this.range = 1; 
								this.speed = 0.001;
								this.attack = 5; 
								this.gObject = new Rectangle(center, 0.0625, 0.0625);
							}
						}
						else if(this.shape == "triangle")
						{
							if (Cookies.get('gameid') && (newUnit == false)) {
								this.health = s.health;
								this.range = s.range;
								this.speed = s.speed;
								this.attack = s.attack;
								this.gObject = new Triangle(center, 0.0625, 0.0625);
								this.gObject.center = s.center;
								this.gObject.right = s.right;
								this.gObject.left = s.left;
								this.gObject.top = s.top;
								this.gObject.bottom = s.bottom;
							} else {
								this.health = 1000; 
								this.range = 0.5; 
								this.speed = 0.005;
								this.attack = 3; 
								this.gObject = new Triangle(center, 0.0625, 0.0625);
							}
						}
						else if(this.shape == "circle")
						{
							if (Cookies.get('gameid') && (newUnit == false)) {
								this.health = s.health;
								this.range = s.range;
								this.speed = s.speed;
								this.attack = s.attack;
								this.gObject = new Circle(center, 0.03125);
								this.gObject.center = s.center;
								this.gObject.right = s.right;
								this.gObject.left = s.left;
								this.gObject.top = s.top;
								this.gObject.bottom = s.bottom;
							} else {
								this.health = 500; 
								this.range = 0.25; 
								this.speed = 0.01;
								this.attack = 1; 
								this.gObject = new Circle(center, 0.03125);
							}
						}

						this.gObject.speed = this.speed;
						this.center = this.gObject.center;
						this.right = this.gObject.right;
						this.left = this.gObject.left;
						this.top = this.gObject.top;
						this.bottom = this.gObject.bottom;				
					}

					Unit.prototype.select = function()
					{
						this.remove();
						this.owner.selected.add(this);
						this.selected = true;
						console.log("Selected");
					}

					Unit.prototype.deselect = function()
					{
						this.remove();
						this.owner.standard.add(this);
						this.selected = false;
						console.log("deselected");
					}

					Unit.prototype.click = function(x, y)
					{
						this.gObject.click(x, y);
						var normalX = 2 * (x / canvas.width) - 1;
						var normalY = -2 * (y / canvas.height) + 1;						

						this.center = this.gObject.center;
						this.right = this.gObject.right;
						this.left = this.gObject.left;
						this.top = this.gObject.top;
						this.bottom = this.gObject.bottom;
						if (!this.selected)
						{
							if (this.in([normalX, normalY]))
							{
								this.select();
								return true;
							} 					
						}
						else
						{
							if (this.in([normalX, normalY]))
							{
								this.deselect();
								return true;
							} 							
						}
						return false;
					}

					Unit.prototype.rightClick = function(x, y)
					{
						var normalX = 2 * (x / canvas.width) - 1;
						var normalY = -2 * (y / canvas.height) + 1;
						if (this.selected)
						{
							console.log("moving");
							this.setDestination([normalX, normalY]);
						}
					}

					Unit.prototype.update = function()
					{
						this.gObject.update();
						this.center = this.gObject.center;
						this.right = this.gObject.right;
						this.left = this.gObject.left;
						this.top = this.gObject.top;
						this.bottom = this.gObject.bottom;
					}

					Unit.prototype.draw = function(toDraw)
					{
						this.gObject.draw(toDraw);
					}

					Unit.prototype.takeDamage = function(damage)
					{
						this.health -= damage;
						if (this.health == 0)
						{
							this.remove();
						}
					}

					Unit.prototype.dealDamage = function(opponent)
					{
						opponent.takeDamage(this.attack);
					}

					Unit.prototype.setDestination = function(destination)
					{
						this.gObject.setDestination(destination);
						this.moving = true;
						this.destination = destination;
					}

					Unit.prototype.setPos = function(center)
					{
						this.center = center;
						this.gObject.setPos(center);
						this.right = this.gObject.right;
						this.left = this.gObject.left;
						this.top = this.gObject.top;
						this.bottom = this.gObject.bottom;
					}

					Unit.prototype.inRange = function(other)
					{
						var distance = Math.sqrt(Math.pow(other.center[0] - this.center[0], 2) + Math.pow(other.center[1] - this.center[1], 2));
						if(distance < this.range)
						{
							return true;
						}
						else
						{
							return false;
						}
					}

					Unit.prototype.in = function(point)
					{
						/*Checks if point is in Unit*/
						if(point[0] < this.gObject.right && point[0] > this.gObject.left && point[1] < this.gObject.top && point[1] > this.gObject.bottom)
						{
							return true;
						}
						else
						{
							return false;
						}
					}

					Unit.prototype.remove = function()
					{
						this.dGroup.remove(this);
					}

					Unit.prototype.collisionTrigger = function(collideWith)
					{
						if (collideWith.constructor.name == "Unit" || collideWith.constructor.name == "Base")
						{	
							this.moving = false;
							var newPos;
							var distanceToMove = 0.01; //TODO: Tune me
							var xvector = this.center[0] - collideWith.center[0];
							var yvector = this.center[1] - collideWith.center[1];
							mag = Math.sqrt(xvector * xvector + yvector * yvector);
							xunit = 1 * xvector / mag;
							yunit = 1 * yvector / mag;
							newPos = [this.center[0] + xunit * distanceToMove, this.center[1] + yunit * distanceToMove]
							this.setPos(newPos);
						}
					}

					/*==================== RESOURCE CLASS===================== */

					function Resource(center, shape)
					{
						this.player = null; //instance of player class
						this.timeoutHandle = null;
						this.shape = shape;
						this.acquireRate = 50; //amount per second

						if(this.shape == "rectangle")
						{
							this.gObject = new Rectangle(center, 0.06125, 0.06125);
						}
						else if(this.shape == "triangle")
						{
							this.gObject = new Triangle(center, 0.06125, 0.06125);
						}
						else if(this.shape == "circle")
						{
							this.gObject = new Circle(center, 0.06125);
						}

						this.center = this.gObject.center;
						this.right = this.gObject.right;
						this.left = this.gObject.left;
						this.top = this.gObject.top;
						this.bottom = this.gObject.bottom;
					}

					Resource.prototype.claim = function(player)
					{
						this.player = player;
						this.remove();
						this.player.standard.add(this);
					}

					Resource.prototype.remove = function()
					{
						this.dGroup.remove(this);
					}

				
					Resource.prototype.update = function()
					{						
						
					}

					Resource.prototype.collisionTrigger = function(collideWith)
					{
						if (collideWith.constructor.name == "Unit")
						{
							this.claim(collideWith.owner);
						}
					}

					Resource.prototype.draw = function(toDraw)
					{
						this.gObject.draw(toDraw);
					}

					Resource.prototype.in = function(point)
					{
						/*Checks if point is in Unit*/
						if(point[0] < this.gObject.right && point[0] > this.gObject.left && point[1] < this.gObject.top && point[1] > this.gObject.bottom)
						{
							return true;
						}
						else
						{
							return false;
						}
					}

					Resource.prototype.click = function(x, y)
					{
						this.gObject.click(x, y);
					}

					/*========================== BASE CLASS ======================== */

					function Base(center, owner)
					{
						this.center = center;
						this.gObject = new Rectangle(center, 0.25, 0.25);
						this.health = 15000;
						this.owner = owner;
					}					

					Base.prototype.click = function(x, y)
					{
						this.gObject.click(x, y);
						var normalX = 2 * (x / canvas.width) - 1;
						var normalY = -2 * (y / canvas.height) + 1;
						if (this.in([normalX, normalY]))
						{
							return true;
						} 					
						else
						{
							return false;
						}
					}

					Base.prototype.rightClick = function(x, y)
					{						
					}

					Base.prototype.update = function()
					{
						this.gObject.update();
						this.center = this.gObject.center;
						this.right = this.gObject.right;
						this.left = this.gObject.left;
						this.top = this.gObject.top;
						this.bottom = this.gObject.bottom;
					}

					Base.prototype.draw = function(toDraw)
					{
						this.gObject.draw(toDraw);
					}

					Base.prototype.takeDamage = function(damage)
					{
						console.log("Base taking damage");
						this.health -= damage;
						if (this.owner.human == false /*&& this.owner.status != "defend"*/) { // This should always happen so that there can be a countdown in the player class
							this.owner.defendBase();
						}

						if (this.health <= 0)
						{
							this.remove();
						}
					}

					Base.prototype.dealDamage = function(opponent)
					{
					}

					Base.prototype.setDestination = function(destination)
					{						
					}

					Base.prototype.setPos = function(center)
					{
						this.center = center;
						this.gObject.setPos(center);
						this.right = this.gObject.right;
						this.left = this.gObject.left;
						this.top = this.gObject.top;
						this.bottom = this.gObject.bottom;
					}

					Base.prototype.in = function(point)
					{
						/*Checks if point is in Base*/
						if(point[0] < this.gObject.right && point[0] > this.gObject.left && point[1] < this.gObject.top && point[1] > this.gObject.bottom)
						{
							return true;
						}
						else
						{
							return false;
						}
					}

					Base.prototype.remove = function()
					{
						this.dGroup.remove(this);
						if (this.owner.human)
						{
							document.getElementById('WinOrLose').innerHTML = "You lose!";
							alert("GAME OVER!\nYou lose!");
						}
						else
						{
							document.getElementById("WinOrLose").innerHTML = "You win!";
							alert("GAME OVER!\nYou win!");
						}

						
					}

					Base.prototype.collisionTrigger = function(collideWith)
					{
					}

					/*=============================  RECTANGLE CLASS =================================*/

					function Rectangle(center, width, height)
					{
						/*
						Class for rectangles
						*/
						this.width = width;
						this.height = height;
						this.setPos(center, width, height);
						this.speed = 0.01; 
					}

					Rectangle.prototype.draw = function(toDraw) //adds its info to the buffer
					{
						var i;
						for (i=0; i < this.screenPos.length; i++)
						{
							toDraw.v[toDraw.index+i] = this.screenPos[i];
						}
						toDraw.index += this.screenPos.length;

						var vbuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                            
						gl.bufferData(gl.ARRAY_BUFFER, toDraw.v, gl.STATIC_DRAW);

						toDraw.index += this.screenPos.length;
					}

					Rectangle.prototype.click = function(posx, posy)
					{
					}

					Rectangle.prototype.update = function()
					{
						/*=================  MOVEMENT =======================*/
						if (this.moving)
						{
							//TODO: add pathfinding code!
							xvector = this.destination[0] - this.center[0]; 
							yvector = this.destination[1] - this.center[1];
							mag = Math.sqrt(xvector * xvector + yvector * yvector);
							xunit = xvector / mag;
							yunit = yvector / mag;
							newPos = [this.center[0] + xunit * this.speed, this.center[1] + yunit * this.speed]
							this.setPos(newPos); 
						}
						if (this.center == this.destination)
						{
							this.moving = false;
						}
					}

					Rectangle.prototype.setDestination = function(destination)
					{
						this.moving = true;
						this.destination = destination;
					}

					Rectangle.prototype.setPos = function(center)
					{
						this.screenPos = [center[0] - (this.width / 2), center[1] + (this.height / 2) * aspect ,
										center[0] + (this.width / 2), center[1] + (this.height / 2) * aspect ,
										center[0] - (this.width / 2), center[1] - (this.height / 2) * aspect ,
										center[0] - (this.width / 2), center[1] - (this.height / 2) * aspect ,
										center[0] + (this.width / 2), center[1] + (this.height / 2) * aspect ,
										center[0] + (this.width / 2), center[1] - (this.height / 2) * aspect ];

						this.center = center;
						this.top = center[1] + (this.height / 2)  * aspect;
						this.bottom = center[1] - (this.height / 2) * aspect;
						this.right = center[0] + (this.width / 2);
						this.left = center[0] - (this.width / 2);
					}

					Rectangle.prototype.in = function(point)
					{
						/*Checks if point is in rectangle*/
						if(point[0] < this.right && point[0] > this.left && point[1] < this.top && point[1] > this.bottom)
						{
							return true;
						}
						else
						{
							return false;
						}
					}

					/*========================================================  TRIANGLE CLASS =======================================================*/

					function Triangle(center, width, height)
					{
						/*
						Class for (equilateral) Triangles
						*/
						this.width = width;
						this.height = height;
						this.setPos(center, width, height);
						this.speed = 0.01; 
					}

					Triangle.prototype.draw = function(toDraw) //adds its info to the buffer
					{
						var i;
						for (i=0; i < this.screenPos.length; i++)
						{
							toDraw.v[toDraw.index+i] = this.screenPos[i];
						}
						toDraw.index += this.screenPos.length;

						var vbuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                            
						gl.bufferData(gl.ARRAY_BUFFER, toDraw.v, gl.STATIC_DRAW);

						toDraw.index += this.screenPos.length;
					}

					Triangle.prototype.click = function(posx, posy)
					{						
					}

					Triangle.prototype.update = function()
					{
						/*=================  MOVEMENT =======================*/
						if (this.moving)
						{
							//TODO: add pathfinding code!
							xvector = this.destination[0] - this.center[0]; 
							yvector = this.destination[1] - this.center[1];
							mag = Math.sqrt(xvector * xvector + yvector * yvector);
							xunit = xvector / mag;
							yunit = yvector / mag;
							newPos = [this.center[0] + xunit * this.speed, this.center[1] + yunit * this.speed]
							this.setPos(newPos); 
						}
						if (this.center == this.destination)
						{
							this.moving = false;
						}
					}

					Triangle.prototype.setDestination = function(destination)
					{
						this.moving = true;
						this.destination = destination;
					}

					Triangle.prototype.setPos = function(center)
					{
						this.v1 = [center[0] - (this.width / 2), center[1] - (this.height / 2) * aspect];
						this.v2 = [center[0], center[1] + (this.height / 2) * aspect];
						this.v3 = [center[0] + (this.width / 2), center[1] - (this.height / 2) * aspect];

						this.screenPos = [this.v1[0], this.v1[1] ,
										this.v2[0], this.v2[1] ,
										this.v3[0], this.v3[1] ,
										];

						this.center = center;
						this.top = center[1] + (this.height / 2)  * aspect;
						this.bottom = center[1] - (this.height / 2) * aspect;
						this.right = center[0] + (this.width / 2);
						this.left = center[0] - (this.width / 2);
					}

					Triangle.prototype.in = function(point, test=false)
					{
						if(test)
						{
							console.log("point");
							console.log(point)
							console.log("First");
							console.log(((this.v2[0] - this.v1[0]) / (this.v2[1] - this.v1[1]) * point[1] + this.v1[0] < point[0]));  
							console.log("Second");
							console.log(((this.v2[0] - this.v3[0]) / (this.v2[1] - this.v3[1]) * point[1] + this.v3[0] > point[0])); 
							console.log("Third");
							console.log(((this.v2[1] - this.v1[1]) / (this.v2[0] - this.v1[0]) * point[0] + this.v1[1] < point[1]));
							console.log("Fourth"); 
							console.log(((this.v3[1] - this.v2[1]) / (this.v3[0] - this.v2[0]) * point[0] + this.v2[1] > point[1]));
						}

						//TODO: Remove and replace with triangle's real code
						if(point[0] < this.right && point[0] > this.left && point[1] < this.top && point[1] > this.bottom)
						{
							return true;
						}
						/*Checks if point is in triangle*/
						// if( ((this.v2[0] - this.v1[0]) / (this.v2[1] - this.v1[1]) * point[1] + this.v1[0] < point[0]) && 
						// 	((this.v2[0] - this.v3[0]) / (this.v2[1] - this.v3[1]) * point[1] + this.v3[0] > point[0]) &&
						// 	((this.v2[1] - this.v1[1]) / (this.v2[0] - this.v1[0]) * point[0] + this.v1[1] < point[1]) && 
						// 	((this.v3[1] - this.v2[1]) / (this.v3[0] - this.v2[0]) * point[0] + this.v2[1] > point[1]))
						// {
						// 	return true;
						// }
						else
						{
							return false;
						}
					}

					/*========================================================  CIRCLE CLASS =======================================================*/
					function Circle(center, radius, triangles=10)
					{
						/*
						Class for (equilateral) Circles
						*/
						this.radius = radius;
						this.setPos(center, radius);
						this.selected = false;
						this.speed = 0.01; 
						this.triangles=triangles; //number of triangles used to create a circle
					}

					Circle.prototype.draw = function(toDraw) //adds its info to the buffer
					{
						var i;
						for (i=0; i < this.screenPos.length; i++)
						{
							toDraw.v[toDraw.index+i] = this.screenPos[i];
						}
						toDraw.index += this.screenPos.length;

						var vbuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                            
						gl.bufferData(gl.ARRAY_BUFFER, toDraw.v, gl.STATIC_DRAW);

						toDraw.index += this.screenPos.length;
					}

					Circle.prototype.click = function(posx, posy)
					{						
					}

					Circle.prototype.update = function()
					{
						/*=================  MOVEMENT =======================*/
						if (this.moving)
						{
							//TODO: add pathfinding code!
							xvector = this.destination[0] - this.center[0]; 
							yvector = this.destination[1] - this.center[1];
							mag = Math.sqrt(xvector * xvector + yvector * yvector);
							xunit = xvector / mag;
							yunit = yvector / mag;
							newPos = [this.center[0] + xunit * this.speed, this.center[1] + yunit * this.speed]
							this.setPos(newPos); 
						}
						if (this.center == this.destination)
						{
							this.moving = false;
						}
					}

					Circle.prototype.setDestination = function(destination)
					{
						this.moving = true;
						this.destination = destination;
					}

					Circle.prototype.setPos = function(center)
					{
						// this.v1 = [center[0] - (this.width / 2), center[1] - (this.height / 2) * aspect];
						// this.v2 = [center[0], center[1] + (this.height / 2) * aspect];
						// this.v3 = [center[0] + (this.width / 2), center[1] - (this.height / 2) * aspect];
						var newScreenPos = [];
						var i;
						var wedgesize = 2 * Math.PI / 10;
						var theta = 0;
						for(i = 0; i < 20; i++)
						{
							// console.log(theta);
							newScreenPos.push(center[0]); newScreenPos.push(center[1]);
							newScreenPos.push(center[0] + this.radius * Math.cos(theta)); newScreenPos.push(center[1] + (this.radius * Math.sin(theta)) * aspect);
							theta += wedgesize;
							newScreenPos.push(center[0] + this.radius * Math.cos(theta)); newScreenPos.push(center[1] + (this.radius * Math.sin(theta)) * aspect);
						}
						// console.log(newScreenPos);
						this.screenPos = newScreenPos;

						this.center = center;
						this.top = center[1] + (this.radius)  * aspect;
						this.bottom = center[1] - (this.radius) * aspect;
						this.right = center[0] + (this.radius);
						this.left = center[0] - (this.radius);
					}

					Circle.prototype.in = function(point, test=false)
					{

						//TODO: Remove and replace with Circle's real code
						if(point[0] < this.right && point[0] > this.left && point[1] < this.top && point[1] > this.bottom)
						{
							return true;
						}
						/*Checks if point is in Circle*/
						// if( ((this.v2[0] - this.v1[0]) / (this.v2[1] - this.v1[1]) * point[1] + this.v1[0] < point[0]) && 
						// 	((this.v2[0] - this.v3[0]) / (this.v2[1] - this.v3[1]) * point[1] + this.v3[0] > point[0]) &&
						// 	((this.v2[1] - this.v1[1]) / (this.v2[0] - this.v1[0]) * point[0] + this.v1[1] < point[1]) && 
						// 	((this.v3[1] - this.v2[1]) / (this.v3[0] - this.v2[0]) * point[0] + this.v2[1] > point[1]))
						// {
						// 	return true;
						// }
						else
						{
							return false;
						}
					}




					/*========================================================  FILE RETRIEVAL AND UPLOAD REQUESTS =======================================================*/

					/**
					 * setFile(unit)
					 * Function that sends unit object data to server to be
					 * processed as an individual file in the game id directory.
					 * 
					 * Parameter: unit (Object)
					 * Return Value: true (If successful)
					*/
					function setFile(unit) { //SINGLE FILE UPLOAD REQUEST 
						var httpRequest = new XMLHttpRequest();
						var url = "http://web.engr.oregonstate.edu/~sibailaj/framework/handler.php";
						var payload = JSON.stringify(unit);

						console.log(payload);

						if (httpRequest) {
							httpRequest.onreadystatechange = handle;
							httpRequest.open('POST', url, true);
							httpRequest.setRequestHeader("Content-type", "application/json");
							httpRequest.send(payload);
						}

						function handle() {
							if (httpRequest.readyState === 4 && httpRequest.status === 200) {
								
								return true;									
							} else {
								//alert("Error: Bad Request");
							}
						}
					}

					/**
					 * getFiles(id)
					 * Function that retrieves all unit object data from server
					 * from the specified game id directory.
					 * 
					 * Parameter: id (Integer)
					 * Return Value: unitArray (Array of unit objects)
					*/
					function getFiles(gameid) { //GAME DATA RETRIEVAL REQUEST
						var httpRequest = new XMLHttpRequest();
						var url = "http://web.engr.oregonstate.edu/~sibailaj/framework/handler.php?gameid=" + gameid;
						var unitObject = new Object();

						if (httpRequest) {
							httpRequest.onreadystatechange = handle;
							httpRequest.open('GET', url, true);
							httpRequest.send();
						}

						function handle() {
							if (httpRequest.readyState === httpRequest.DONE) {
								if (httpRequest.status === 200) {
									//Parse JSON Data
									unitObject = JSON.parse(httpRequest.responseText);
									//loadGame(unitObject);
								}
							}
						}
					}

					/**
					 * prepData(id, p1, p2, r1, r2, r3, b1, b2)
					 * Function that formats Player instances before sending
					 * to server to save as unit data files. Also saves non-unit data
					 * as cookies on server.
					 * 
					 * Parameters: id (Integer), p1, p2 (Player Instances),
					 * r1, r2, r3 (Resource Instances), b1, b2 (Base Instances)'
					 *
					 * Return Value: true (if all requests were successful)
					*/
			        function prepData(gameid, p1, p2, r1, r2, r3, b1, b2) {
			        	var success;
			        	var unitArray = [];
			        	var x;
			        	var unitObject;

			        	Cookies.set('p1', JSON.stringify(p1, replacer));
			        	Cookies.set('p2', JSON.stringify(p2, replacer));
			        	Cookies.set('r1', JSON.stringify(r1, replacer));
			        	Cookies.set('r2', JSON.stringify(r2, replacer));
			        	Cookies.set('r3', JSON.stringify(r3, replacer));
			        	Cookies.set('b1', JSON.stringify(b1, replacer));
			        	Cookies.set('b2', JSON.stringify(b2, replacer));

			        	//Build Unit Array
			        	//Add Human Player's Units
			        	if (p1.hasOwnProperty("standard")) {
				        	if (p1.standard.hasOwnProperty("group")) {
					        	for (x = 0; x < p1.standard.group.length; x++) {
					        		if (p1.standard.group[x] instanceof Unit) {
					        			unitArray.push(p1.standard.group[x]);
					        		}
					        	}
				        	}
				        }

			        	//Add AI's Units
			        	if (p2.hasOwnProperty("standard")) {
				        	if (p2.standard.hasOwnProperty("group")) {			        	
					        	for (x = 0; x < p2.standard.group.length; x++) {
					        		if (p2.standard.group[x] instanceof Unit) {
					        			unitArray.push(p2.standard.group[x]);
					        		}
					        	}
							}
						}

			          	for (var i = 0; i < unitArray.length; i++) {

				            unitObject = new Object();

				            if (i == 0) {				            	
				            	unitObject.create = 1;
				            } else {
			              		unitObject.create = 0;
			            	}			            	

			            	//Build Unit Object
			            	unitObject.gameid = gameid;
			            	unitObject.attack = unitArray[i].attack;
			            	unitObject.bottom = unitArray[i].bottom;
			            	unitObject.center = unitArray[i].center;
			            	unitObject.gObject = unitArray[i].gObject;
			            	unitObject.health = unitArray[i].health;
			            	unitObject.index = unitArray[i].index;
			            	unitObject.left = unitArray[i].left;
			            	unitObject.human = unitArray[i].owner.human;
			            	unitObject.paper = unitArray[i].owner.paper;
			            	unitObject.rock = unitArray[i].owner.rock;
			            	unitObject.scissors = unitArray[i].owner.scissors;
			            	unitObject.range = unitArray[i].range;
			            	unitObject.right = unitArray[i].right;
			            	unitObject.selected = unitArray[i].selected;
			            	unitObject.shape = unitArray[i].shape;
			            	unitObject.speed = unitArray[i].speed;
			            	unitObject.top = unitArray[i].top;
			            	unitObject.index = i + 1;

			            	if (unitArray[i].owner.human == true) {
			            		unitObject.player = "human";
			            	} else {
			            		unitObject.player = "ai";
			            	}

			          		success = setFile(unitObject);
			        	}
			        	return success;

			        	function replacer(key, value) {
				        	if (typeof value === "object") {
				        		if (key === "dGroup") {
				        			return undefined;
				        		} else if (key === "owner") {
				        			return undefined;
				        		} else if (key === "v") {
				        			return undefined;
				        		} else if (value instanceof Unit) {
				        			return undefined;
				        		}
				        	}
				        	return value;
				        }
			        }


			</script>
	</head>
	<body onload="init()" onresize="resize()">
		    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
		    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
		    <!-- Include all compiled plugins (below), or include individual files as needed -->
		    <script src="js/bootstrap.min.js"></script>

		    <!-- Fixed navbar -->
		    <nav class="navbar navbar-inverse navbar-fixed-top">
		      <div class="container">
		        <div class="navbar-header">
		          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
		            <span class="sr-only">Toggle navigation</span>
		            <span class="icon-bar"></span>
		            <span class="icon-bar"></span>
		            <span class="icon-bar"></span>
		          </button>
		          <a class="navbar-brand" href="#">Rock-Paper-Scissors RTS</a>
		        </div>
		        <div id="navbar" class="navbar-collapse collapse">
		          <ul class="nav navbar-nav navbar-right">
		            <li><a href="instructions.html" onClick="return popup(this, 'notes')">Instructions</a></li>
		          </ul>
		        </div><!--/.nav-collapse -->
		      </div>
		    </nav>

			<p id="Controls">Spawn rock: 'q', Spawn paper 'w', Spawn scissors 'e', Left click and drag to select, right click to move</p>
			<canvas id="mycanvas" width="1600" height="1000"></canvas>
			<div style="display: inline; float: right; margin-right: 40px; margin-top:20px;">
			<p id="WinOrLose"></p>
			<p id="rock resource">0</p>
			<p id="paper resource">0</p>
			<p id="scissors resource">0</p>
			<input type="button" class="btn btn-lg btn-default" id="new" value="New Game">
			<input type="button" class="btn btn-lg btn-default" id="save" value="Save Game">				
			</div>
			<canvas id="mycanvas" width="800" height="500"></canvas>



			
	</body>
</html>
 <html>
	<head>           
			<script id="vertex" type="x-shader">
				attribute vec2 aVertexPosition;
				void main() 
				{
					gl_Position = vec4(aVertexPosition, 0.0, 1.0);
				}
			</script>  

			<script id="fragment" type="x-shader">
				    #ifdef GL_ES
					precision highp float;
					#endif
					uniform vec4 uColor;
					                       
					void main() 
					{
						gl_FragColor = uColor;
					}
			</script>        
			<script type="text/javascript">

					var gl;
					var aspect;
					var vbuffer;
					var program;
					var index; //temp until the buffer class is ready

					function init()
					{
						//set up canvas and webgl context
						canvas = document.getElementById("mycanvas");
					    gl = canvas.getContext("experimental-webgl"); //
						gl.viewport(0, 0, canvas.width, canvas.height);
						gl.clearColor(0, 0.5, 0, 1); //drawing viewfinder color
						gl.clear(gl.COLOR_BUFFER_BIT);
						
						// compile and set up shaders
			    		var v = document.getElementById("vertex").firstChild.nodeValue;
						var f = document.getElementById("fragment").firstChild.nodeValue;
						 
						var vs = gl.createShader(gl.VERTEX_SHADER);
						gl.shaderSource(vs, v);
						gl.compileShader(vs);
						
						var fs = gl.createShader(gl.FRAGMENT_SHADER);
						gl.shaderSource(fs, f);
						gl.compileShader(fs);
						
						program = gl.createProgram();
						gl.attachShader(program, vs);
						gl.attachShader(program, fs);
						gl.linkProgram(program);

						if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
							console.log(gl.getShaderInfoLog(vs));

						if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
							console.log(gl.getShaderInfoLog(fs));

						if (!gl.getProgramParameter(program, gl.LINK_STATUS))
							console.log(gl.getProgramInfoLog(program));

						//set up arrays
						aspect = canvas.width / canvas.height;

						maxUnits = 1000 //temp
						var toDraw = new Vertices(maxUnits); //new Float32Array(maxUnits * 12); //12 points per unit?
						index = 0

						// var arr = [-0.25, 0*aspect, 0, 0*aspect,  0, -0.25*aspect,  // Triangle 1
						// 	-0.25, 0*aspect, 0, -0.25*aspect, -0.25, -0.25*aspect]   // Triangle 2

						r1 = new Rectangle(0, 0, 0, 1);
						r2 = new Rectangle(0, 0, 0, 2);
						r1.draw(toDraw);
						r2.draw(toDraw);
						// drawRect(vertices, 0, 0, 0);
						// drawAnotherRect(vertices, 0, 0, 0);

						itemSize = 2;
						numItems = toDraw.v.length / itemSize;

						//gl
						gl.useProgram(program);
     
						program.uColor = gl.getUniformLocation(program, "uColor"); //get color from program
						gl.uniform4fv(program.uColor, [0.0, 0.3, 0.0, 1.0]); //set color

						program.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"); //get vertex position from program
						gl.enableVertexAttribArray(program.aVertexPosition);
						gl.vertexAttribPointer(program.aVertexPosition, itemSize, gl.FLOAT, false, 0, 0);
						
						//draw
						gl.drawArrays(gl.TRIANGLES, 0, numItems);
					}

					function Vertices(maxUnits)
					{
						this.v = new Float32Array(maxUnits*12);
						this.index = 0;
					}

					function Rectangle(center, width, height, temp)
					{
						/*
						Class for rectangles
						*/
						if(temp == 1)
						{
							this.screenPos = [-0.25, 0*aspect, 0, 0*aspect,  0, -0.25*aspect,  // Triangle 1
									-0.25, 0*aspect, 0, -0.25*aspect, -0.25, -0.25*aspect];   // Triangle 2
						}
						else if(temp == 2)
						{
							this.screenPos = [0, .25*aspect, .25, .25*aspect,  .25, 0*aspect,  // Triangle 1
							0, .25*aspect, .25, 0*aspect, 0, 0*aspect];   // Triangle 2
						}

						//this.draw();
						// for (i=0; i < this.screenPos.length; i++)
						// {
						// 	vertices.v[vertices.index+i] = this.screenPos[i];
						// }
						// vertices.index += this.screenPos.length;

						// vbuffer = gl.createBuffer();
						// gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                                       
						// gl.bufferData(gl.ARRAY_BUFFER, vertices.v, gl.STATIC_DRAW);

						// vertices.index += this.screenPos.length;
						
					}

					Rectangle.prototype.draw = function(toDraw) //adds its info to the buffer
					{
						for (i=0; i < this.screenPos.length; i++)
						{
							toDraw.v[toDraw.index+i] = this.screenPos[i];
						}
						toDraw.index += this.screenPos.length;

						vbuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                                       
						gl.bufferData(gl.ARRAY_BUFFER, toDraw.v, gl.STATIC_DRAW);

						toDraw.index += this.screenPos.length;
					}

					function drawRect(vertices, center, width, height)
					{
						//TODO: replace with 

						var arr = [-0.25, 0*aspect, 0, 0*aspect,  0, -0.25*aspect,  // Triangle 1
							-0.25, 0*aspect, 0, -0.25*aspect, -0.25, -0.25*aspect]   // Triangle 2

						for (i=0; i < arr.length; i++)
						{
							vertices.v[vertices.index+i] = arr[i];
						}
						vertices.index += arr.length;

						vbuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                                       
						gl.bufferData(gl.ARRAY_BUFFER, vertices.v, gl.STATIC_DRAW);

						return vertices;
					}

					function drawAnotherRect(vertices, center, width, height)
					{
						var arr = [0, .25*aspect, .25, .25*aspect,  .25, 0*aspect,  // Triangle 1
							0, .25*aspect, .25, 0*aspect, 0, 0*aspect]   // Triangle 2

						for (i=0; i < arr.length; i++)
						{
							vertices.v[vertices.index+i] = arr[i];
						}
						vertices.index += arr.length;

						vbuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                                       
						gl.bufferData(gl.ARRAY_BUFFER, vertices.v, gl.STATIC_DRAW);

						return vertices;
					}


			</script>
	</head>
	<body onload="init()">
			<canvas id="mycanvas" width="800" height="500"></canvas>
	</body>
</html>
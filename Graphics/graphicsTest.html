 <html>
	<head>           
			<script id="vertex" type="x-shader">
				attribute vec2 aVertexPosition;
				void main() 
				{
					gl_Position = vec4(aVertexPosition, 0.0, 1.0);
				}
			</script>  

			<script id="fragment" type="x-shader">
				    #ifdef GL_ES
					precision highp float;
					#endif
					uniform vec4 uColor;
					                       
					void main() 
					{
						gl_FragColor = uColor;
					}
			</script>        
			<script type="text/javascript">

					var gl;
					var aspect;
					var vbuffer;
					var program;
					var gl;
					//var index; //temp until the buffer class is ready

					function init()
					{
						canvas = document.getElementById("mycanvas");

						/*========================= CAPTURE MOUSE EVENTS ========================= */
						var drag=false;
						var old_x, old_y;
						var mouseDownEvent;
						var mouseUpEvent;
						var mouseDown=function(e) 
						{
							mouseDownEvent = true;
							drag=true;
							old_x=e.pageX, old_y=e.pageY;
							e.preventDefault();
							return false;
						};

						var mouseUp=function(e)
						{
							mouseUpEvent = true
							drag=false;
						};

						var mouseMove=function(e) 
						{
							if (!drag) return false;
							var dX=e.pageX-old_x,
							    dY=e.pageY-old_y;
							THETA+=dX*2*Math.PI/canvas.width;
							PHI+=dY*2*Math.PI/canvas.height;
							old_x=e.pageX, old_y=e.pageY;
							e.preventDefault();
						};

						canvas.addEventListener("mousedown", mouseDown, false);
						canvas.addEventListener("mouseup", mouseUp, false);
						canvas.addEventListener("mouseout", mouseUp, false);
						canvas.addEventListener("mousemove", mouseMove, false);

						/*========================= CANVAS AND SHADERS ========================= */
					    gl = canvas.getContext("experimental-webgl"); //
						gl.viewport(0, 0, canvas.width, canvas.height);
						gl.clearColor(0, 0.5, 0, 1); //drawing viewfinder color
						gl.clear(gl.COLOR_BUFFER_BIT);
						
			    		var v = document.getElementById("vertex").firstChild.nodeValue;
						var f = document.getElementById("fragment").firstChild.nodeValue;
						 
						var vs = gl.createShader(gl.VERTEX_SHADER);
						gl.shaderSource(vs, v);
						gl.compileShader(vs);
						
						var fs = gl.createShader(gl.FRAGMENT_SHADER);
						gl.shaderSource(fs, f);
						gl.compileShader(fs);
						
						program = gl.createProgram();
						gl.attachShader(program, vs);
						gl.attachShader(program, fs);
						gl.linkProgram(program);

						if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
							console.log(gl.getShaderInfoLog(vs));

						if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
							console.log(gl.getShaderInfoLog(fs));

						if (!gl.getProgramParameter(program, gl.LINK_STATUS))
							console.log(gl.getProgramInfoLog(program));

						//set up arrays
						aspect = canvas.width / canvas.height;

						maxUnits = 1000 //temp
						var toDraw = new DrawGroup(maxUnits); //new Float32Array(maxUnits * 12); //12 points per unit?

						r1 = new Rectangle([0, 0], 0.25, 0.25);
						r2 = new Rectangle([0, 0], 0.25, 0.25);
						r3 = new Rectangle([0, 0.25], 0.25, 0.25);
						r4 = new Rectangle([0.25, 0], 0.25, 0.25);

						toDraw.group.push(r1);
						//toDraw.group.push(r2);


						var groupToDraw = 0;
						function update()
						{
							// if (groupToDraw == 0)
							// {
							// 	toDraw.group = []
							// 	toDraw.group.push(r1);
							// 	toDraw.group.push(r2);
							// 	groupToDraw = 1;
							// }
							// else
							// {
							// 	toDraw.group = []
							// 	toDraw.group.push(r3);
							// 	toDraw.group.push(r4);
							// 	groupToDraw = 0;
							// }

							if (mouseDownEvent)
							{
								mouseDownEvent = false;	
								var i; 
								for(i=0; i < toDraw.group.length; i++)
								{
									toDraw.group[i].mouseDown(old_x, old_y);
								}
							}
							else if (mouseUpEvent)
							{
								mouseUpEvent = false;
							}
						}

						function drawLoop()
						{
							toDraw.clear();
							gl.clear(gl.COLOR_BUFFER_BIT);
							var i;
							for(i=0; i < toDraw.group.length; i++)
							{
								toDraw.group[i].draw(toDraw);
							}

							toDraw.render();
						}

						setInterval(update, 20);

						setInterval(drawLoop, 16);
					}

					function DrawGroup(maxUnits)
					{
						this.v = new Float32Array(maxUnits*12);
						var i;
						for(i=0; i < this.v.length; i++)
						{
							this.v[i] = 0;
						}
						this.index = 0;
						this.group = [];
					}

					DrawGroup.prototype.render = function()
					{
						itemSize = 2;
						numItems = this.v.length / itemSize;

						//gl
						gl.useProgram(program);
     
						program.uColor = gl.getUniformLocation(program, "uColor"); //get color from program
						gl.uniform4fv(program.uColor, [0.0, 0.3, 0.0, 1.0]); //set color

						program.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"); //get vertex position from program
						gl.enableVertexAttribArray(program.aVertexPosition);
						gl.vertexAttribPointer(program.aVertexPosition, itemSize, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.TRIANGLES, 0, numItems)
					}

					DrawGroup.prototype.clear = function()
					{
						var i;
						for (i=0; i < this.v.length; i++)
						{
							if(this.v[i] != 0)
							{
								this.v[i] = 0;
							}
						}
						this.index = 0;
					}

					function Rectangle(center, width, height)
					{
						/*
						Class for rectangles
						*/
						this.width = width;
						this.height = height;
						this.setPos(center, width, height);
						// this.screenPos = [center[0] - (width / 2), (center[1] + (height / 2)) * aspect,
						// 				center[0] + (width / 2), (center[1] + (height / 2)) * aspect,
						// 				center[0] - (width / 2), (center[1] - (height / 2)) * aspect,
						// 				center[0] - (width / 2), (center[1] - (height / 2)) * aspect,
						// 				center[0] + (width / 2), (center[1] + (height / 2)) * aspect,
						// 				center[0] + (width / 2), (center[1] - (height / 2)) * aspect];

						// this.top = center[1] + (height / 2) * aspect;
						// this.bottom = center[1] - (height / 2) * aspect;
						// this.right = center[0] + (width / 2);
						// this.left = center[0] - (width / 2);
					}

					Rectangle.prototype.draw = function(toDraw) //adds its info to the buffer
					{
						var i;
						for (i=0; i < this.screenPos.length; i++)
						{
							toDraw.v[toDraw.index+i] = this.screenPos[i];
						}
						toDraw.index += this.screenPos.length;

						vbuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                                       
						gl.bufferData(gl.ARRAY_BUFFER, toDraw.v, gl.STATIC_DRAW);

						toDraw.index += this.screenPos.length;
					}

					Rectangle.prototype.mouseDown = function(posx, posy)
					{
						//TODO: replace with changing the color of the piece
						// console.log(this.top);
						// console.log(this.bottom);
						// console.log(this.left);
						// console.log(this.right);
						// console.log((posx / canvas.width) - 0.5);
						// console.log((posy / canvas.height) - 0.5);
						normalX = (posx / canvas.width) - 0.5;
						normalY = (posy / canvas.height) - 0.5;
						if (normalX < this.right && normalX > this.left &&
							normalY < this.top && normalY > this.bottom)
						{
							console.log("Selected");
						} 
						else
						{
							console.log("Not selected");
						}
					}

					Rectangle.prototype.setPos = function(center)
					{
						this.screenPos = [center[0] - (this.width / 2), (center[1] + (this.height / 2)) * aspect,
										center[0] + (this.width / 2), (center[1] + (this.height / 2)) * aspect,
										center[0] - (this.width / 2), (center[1] - (this.height / 2)) * aspect,
										center[0] - (this.width / 2), (center[1] - (this.height / 2)) * aspect,
										center[0] + (this.width / 2), (center[1] + (this.height / 2)) * aspect,
										center[0] + (this.width / 2), (center[1] - (this.height / 2)) * aspect];

						this.top = center[1] + (this.height / 2) * aspect;
						this.bottom = center[1] - (this.height / 2) * aspect;
						this.right = center[0] + (this.width / 2);
						this.left = center[0] - (this.width / 2);
					}
			</script>
	</head>
	<body onload="init()">
			<canvas id="mycanvas" width="800" height="500"></canvas>
	</body>
</html>